作为老法师，你是否也曾陷入这样的技术焦虑？“服务中台、明年升级，再不学就要被淘汰了！”“我们的系统还是个单体，是不是太落后了？”“别人的技术那么酷炫，我们是不是也该拆了？”

如果你有这样的疑问，那么最近技术圈一个反常规的趋势或许能让你松一口气——越来越多的公司正在理性评估，甚至主动回归单体架构。这并非技术的倒退，而是一次深刻的理性回归。

等一下，是我看错了吗？2025年你还在讨论回归单体，你是不是太不专业了？别急，上面这段话还真不是我说的，这来自于2025年腾讯开发者社区上的一篇文章：《放下技术焦虑，越来越多公司重回单体架构的真相》。而在这篇针对单体架构和微服务架构“极限拉扯”的文章当中，就不止一次提到了DDD（领域驱动设计）。我们这一次的分享，也就从这篇文章开始。

这次要分享的观点，其实也和这篇文章中一些部分不谋而合：DDD视角下，单体架构与微服务架构是统一的。而在微服务架构的支持下，落地DDD也有了新的思路，那就是“单体优先”——单体架构下把业务快速验证正确后，再把性能比较吃紧的模块逐步拆解成微服务。

之前也做了几期DDD的分享，朋友们问的最多的问题就是“DDD到底怎么落地”。这一期跟你分享一些我的经验，与之前几期一样，我会尽可能把DDD落地这个业界都没有标准答案的事情，分享得尽量通俗易懂、老少咸宜。但我还是要说，这很难，因为架构设计从来就不是人人都能思考的事情。如果你没有真正动手做过DDD的项目，那么你很难去理解DDD到底哪里好、哪里坏。就像MVC，你要是没玩过，其实也很难去理解Model、View、Controller都是些什么“莫名其妙”的东西。不过放心，这一期你也一定会或多或少有所收获，记得关注、点赞，并在评论区多多交流！

言归正传，DDD凭什么能把单体和微服务这两个看似水火不容的架构统一起来？答案就藏在DDD最核心、也是最劝退的概念——**领域上下文（Bounded Context）**。

虽然上一期花了一整个视频单独来介绍领域上下文，但是这一次我还是要再次强调一下这个东西。上一期我把领域上下文比喻成了一个国家的国界线，这个比喻其实并没有夸张。DDD的核心其实就是通过领域上下文保证每个领域可以绝对自治，就像一个国家在自己的领土内可以“为所欲为”。比如，如果在电商中划分出了销售和仓储两个领域，那么这两个领域之间只允许通过领域上下文的“防护墙”相互沟通，除此之外再无关联。哪怕他们都有“商品”的概念，也是两个完全不同的“商品”：在销售领域内，商品就是指价格、利润、SKU，核心就是为了商品去赚钱；但在仓储领域，商品就变成了重量、体积、库存，核心只有一个就是存放。

领域上下文的作用就是要划清这条“三八线”，确保销售别指挥仓库怎么备货，仓库也别去干涉销售怎么定价。它定义了边界、统一了语言、隔离了复杂性，这就是我们能够实现架构统一和平滑演进的关键。如果你了解过之前介绍的DDD四层架构，你想一想就会发现，所谓四层架构，其实核心思想就是把领域上下文这种“国家级的宪法”，下沉到国家内部各个部门之间——本质上都是在强调独立自治。当然这个要说明白就有点复杂了，这个短视频我们就不展开了。

现在最关键的来了：既然“三八线”划好了，那么在自己的地盘，我想怎么搞就必须是我说了算。我给你讲个真事：我以前带过一个团队，也是做一个DDD项目，然后有个哥们是DDD的狂热粉。当时我们规划好了一个“短信发送”的领域上下文，职责其实很简单，就是调第三方的API把验证码发出去，这算是一个独立的“部门”。结果这个人上来就搞DDD的“全家桶”，什么实体、聚合、仓储、领域服务，一层一层码得整整齐齐，搞出一大堆的接口和实现类，就为了封装那个只有一行的API调用。我实在看不下去了，把他叫过来说：“哥们，短信发送其实就是个传话筒，把话传到就完事了，你这一层一层往上加码完全没有必要。”他当时就愣住了，然后弱弱的说了一句：“可书上说标准的DDD就是要分层架构。”我告诉他：“书是死的，人是活的，只要你保证接口功能是稳定的，就完成了你的任务。至于内部怎么搞，那是你说了算，没必要听别人的。”

对那些业务复杂、天天要变的核心领域，比如订单交易，那你上全套DDD，没任何毛病；但对于短信发送这种稳定的纯技术小领域，只要接口稳定、不越边界，你想怎么弄就怎么弄，甚至你就写一个工具类，谁也说不了你什么；同样，对于那些完全不会改变任何数据、不会影响任何业务的数据分析模块，你甚至可以完全当DDD不存在，只要保留好一个接口，其他事情“为所欲为”。记住：DDD是用来解决复杂性的，不是用来制造复杂性的。把领域上下文这个“国界”守住了，你就拥有了在其中自由发挥的能力。

现在领域上下文定了，那具体到代码上，这“三八线”到底是一堵墙还是一行注释呢？都是，也都不是。只不过在Java的世界里，它有个最好的载体——就是接口，我们通常管它叫“防腐层接口”。你别管名字多么高大上，那不重要，重要的是它的作用：定义跨领域合作的官方标准。比如订单模块要查库存模块的商品数量，它不能直接去调库存模块的任何代码，而是调用一个提前写好的接口，比如叫InventoryService。这个接口就是官方合作的协议，模块之间的协作都要基于这个协议。

我们接着往下看：在项目初期，我们可以是一个单体应用，所有“部门”都在一栋楼里面。那订单模块要如何调用到InventoryService接口的具体实现呢？太简单了，在Spring框架的世界里，你只需要一个@Autowired注解，Spring就会在自己的IOC容器里帮你找到那个实现了InventoryService接口的本地Bean，然后把活儿交给它。这个过程本身就是给接口找一个本地实现，这是内部协作，是本地调用。

那后来业务火了，库存部门忙不过来了，就独立出去了，成了库存微服务，搬到另一栋楼里。这时候订单服务还是需要调用那个一模一样的InventoryService接口（这份官方合作协议没变），但@Autowired找不到人了怎么办？这时候就轮到Dubbo或者OpenFeign这些“超级中介”出场了。你一调用接口，Feign就会站出来说：“别急，这活儿我来接！”它会去一个叫“注册中心”的地方查一下库存微服务的地址，然后用网络通信（RPC）的方式把你的请求发过去，拿到结果再返回给你。对于你的订单服务来说，它感觉自己还是在调用一个普普通通的接口，它根本不需要知道背后发生了什么翻天覆地的变化。这个过程本质上还是给接口找一个实现类，只不过这次找到的是一个由Feign创建的远程代理实现类。

好，现在请你退后一步看清全局：从单体架构到微服务，业务没变、接口没变，唯一变化的只是“给接口找实现类”的方式——在单体的时候，我们是通过Spring的本地Bean扫描来找；而在微服务的时候，是通过Feign或者Dubbo这样的远程服务发现框架来找。咱们能不能再懒一点？我们甚至完全可以把这个“寻找实现类的方式”抽象出来，也做成一个可拔插、可配置的协作模式组件，相当于是一个适配器。这样一来，从单体架构往微服务的演进，不再是伤筋动骨的大手术，仅仅只是切换一下组件就这么简单。

领域上下文保证了领域内的独立性，不管采用哪种架构，领域内部都不需要改动——这就是DDD带给我们的、实现架构平滑演进的终极奥秘。在埃里克·埃文斯的《领域驱动设计》这本书中，还总结提出了更全面的七层架构，是对这种思路的进一步拓展，甚至MQ异步通讯也可以纳入这个体系当中，有兴趣的朋友可以去了解一下。

讲到这里，你可能还是会觉得绕来绕去，说到最后不还是微服务吗？但你有没有想过，为什么很多团队，包括我们自己，都曾在微服务里栽过跟头？因为我们常常在最不该做决策的时候，做出了最大的决策。这里就要提到一位大神——Martin Fowler，他是最早提出微服务这个概念的，但同时他早就给我们一个忠告：**单体优先（Monolith First）**。

为什么这么说？想象一下，我们刚接到一个全新的项目，就像是在一片完全陌生的水域里开辟新航线。在出发前，你对这片水域的理解是模糊的，哪里有暗礁、哪里有渔群，你一概不知。这时候如果让你立刻就规划出一支由十艘功能各异的小船组成的微服务舰队，每艘船都负责一个专门的任务（有捕鱼的、有探路的、有导航的等等），你觉得这样靠谱吗？你很可能会把导航船派到一个根本没有路的地方，把捕鱼船派到一片寸草不生的死海——因为你的领域知识是模糊的，边界划分就是一场凭经验的豪赌。

正确的做法是什么？就是Martin Fowler的“单体优先”策略：先开一艘灵活坚固的单体大船出海。在这艘大船上，我们用DDD的领域上下文思想，在甲板上用粉笔划出各个区域的功能。因为大家都在一艘船上，如果发现销售区划得太小了，擦掉重划就行了；如果发现仓储区和导航区的职责搞混了，那么重新沟通调整一下就行了——这就是“船小好掉头”。我们不用过早地去关心性能、分布式事务这些复杂的问题，唯一的目标就是通过一次次的业务“试航”，在实践中找到一个最合理的领域边界。

当我们的航线跑了几十遍，哪里有暗礁、哪里有渔群，我们都了如指掌了，那个时候我们甲板上的粉笔印（领域边界）也就基本固定下来了——这就是我们经过业务反复验证后最终成型的领域上下文。到了这个时候，你发现捕鱼区太忙了，人满为患，严重影响了整艘船的航行速度。好，这时候时机成熟了，启动在上一集说的“切换器”，把这个经过业务反复验证、边界清晰无比的捕鱼区，整体迁移到一艘专门的、马力强劲的捕鱼微服务小船上。你看，这样的微服务拆分，不再是凭空想象，而是基于业务真实压力的自然演进。这样拆分出来的微服务，每一份资源投入都是基于业务需求的合理评估，都是对业务价值的正向贡献。

这也就是那篇文章中提到的几点重要启示：业务驱动技术，而非技术驱动业务；从模块化单体开始；持续演进，而非一步到位。所以，请放下你的技术焦虑。下次当你为技术选型而纠结时，不要再问“这个技术够不够新、够不够酷”，而是问“这对我的团队和业务来说，是最简单、最有效的方法吗？”能够用最简单的方法解决最复杂的问题，才是真正卓越的工程实践（engineering）。

最后我想说，用短视频的形式讲DDD太难了。不管怎么讲，都不会有太大的流量，而且每期短视频只能讲一点点，前后还没法太连贯，不能太深也不能太浅。架构离不开代码，但短视频又不能讲太多代码；每一集前进的幅度不能太大，也不能太小——在短视频时代，这完全就是“找死”。就像这位朋友评论的一样：“了解我的朋友知道，我是程序员，但也是培训讲师。我之前出过好几个小时的系列课程来分享DDD，但这与做短视频相比，实在太简单了。”

在面试题泛滥的短视频平台，做这样的干货视频，既费脑子还没钱，我自己也想过很多次放弃。但是我没想到，有很多朋友鼓励我，有小白也有大神，是你们的理解在支撑我这个“疯狂”的系列走到现在。在此，也感谢大家的支持，这次真是无比真诚地说：你们的鼓励，是我坚持的动力。谢谢大家！