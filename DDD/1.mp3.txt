之前出了一期视频来讨论滴滴滴如何教你设计表结构引起了很多朋友的关注 也有很多朋友留下了各种建议这是我史料为极的一答复肯定答不过来了所以这一次就再出一期续集视频 给大家继续补充滴滴设计表结构之后的细节当时讨论了一个这样的问题电商系统用户可以维护多个收获地址 下单时选一个订单表和地址表你怎么设计在上期视频中我通过对滴滴滴实体和指对象的分析把业务搜缩到用户中心领域订单设计为实体 收获地址设计为指对象直对象必须完全依赖于实体 所以给出了这样的表结构把地址以JSON的形式 容易的订单表中这当然会让很多朋友看得很奇怪但确实是有详细推演过程的 不熟悉的朋友可以看一下我上期的这个视频然后呢 有很多朋友都热情的提出了自己的见解比较有代表性的几个方案 我从评论区里抽取了出来像这样这样这样这样还有这样可以看到 各种方案都有有调整数据结构的 还有换存储的那么沿着滴滴滴的思路来分析 这么多方案 包括我给出的方案 到底哪个更好呢我这里给出一个统一的答复都可以甚至进一步 任何一种存储结构都可以一听到这 肯定就有朋友要说我这在祸袭离了别急 给我五分钟来解释一下保证让你心服口最好也服不服没关系 大家一起继续讨论也不错当然别问了 顺便点个赞 收藏 让报复以来更猛烈些吧后面还有滴滴滴的一整套理论加实战等的出场了我们现在换一个没有那么大正义的电商业务场景在下订单时 一个订单可以包含多个商品 这是一种整体与部分的关系在我们的领域模型里是最理想的设计方式就是一个order内里面直接包含一个商品列表 list product像这样 对吧这个模型非常的干净 完全符合我们的业务直觉但现实是数据是要持久化的在关系型数据库里为了实现这种多对多的关系你至少需要三张表orders表products表以及一张order items表像这样你看理想中一个类包含一个列表的业务模型和现实中三张表的物理存储之间出现了巨大的鸿沟如果你的业务代码是直接去操作这三张表那么你的代码就和mysuckle三张表这些技术的实现细节给焊死了今天你先把mysuckle换成mongo DB或者为了优化性能把三张表合成一张jason存起来那么你的业务代码是不是得从头到脚改变成本太高了DDD其实早就考虑了这个问题他的答案就是引入一个适配层把理想的领域模型和现实的数据存储隔离开这个适配层就是由倉库repository和工厂factory这两个核心组建构成的他们就像一个翻译官或者说是一个数据总代理专门负责弥合这道红钩首先来说倉库他的职责非常的纯粹管理领域对象的生命周期像一个内存集合一样对外提供访问当你的业务逻辑需要一个订单时你只需要跟orderrepository说一句Hey 把id123的订单给我倉库就会先看看这道缓存里面有没有有就直接给你如果没有他就负责从直九层把这个对象捞出来但是倉库他不应该关心这个对象是如何从一堆零散的数据结构中拼接出来的他只负责发出一个获取的指令然后接受一个完整的对象这种职责分离正式为了让倉库保持简单他的核心是管理而不是创建那你肯定会问如果倉库不负责拼装那谁来做这个脏活内活这就是滴滴滴中的工厂factory存在的必要性工厂就是那个主要的装配师专门负责从零散的数据零件中创建和重建一个复杂的领域对象让我们回到订单的例子看看工厂到底有多重要当倉库需要加这个订单时他会委托工厂这是工厂的装配流水线就开始工作第一步调用orderDNO从orders表里查出订单的一些基本信息比如说订单号 创建时间这些第二步拿着订单ID调用orderEtonDNO从orderEton中间表查出所有关联的商品ID和购买的数量第三步这使我们只有一堆商品ID还不够因为我们的order领域模型需要的是完整的product对象列表所以工厂会继续用productDNO继续根据刚经常的商品ID去product表里面把商品的详细信息再查出来第四步现在所有的零件都齐了工厂就可以开始组装了大概news一个order对象再news出来很多个product对象然后再把这些product对象C到order对象的product职列表里面最后一步一个结构完整数据一致的order领域对象就会成功创建工厂把它交付给仓库仓库再返回给业务层看到这个过程了吗这个装配逻辑本身就相当的复杂它协调了多个DNO处理了数据模型和领域模型之间的转换如果把这么重的逻辑和缓程管理失误控制等逻辑都混在仓库的实现里仓库就没法看了因此抽象出工厂就是为了将对象的复杂创建过程本身封装成一个独立的职责让仓库的职责更纯粹让系统的设计更清晰讲了这么多咱们再来一个音合的回到之前那个订单和收获地址的场景在订单这个聚合里收获地址是一个指队像它是下单那一刻的地址快照它和用户中心的那个可以修改的地址实体是两回事现在假设我们的数据库里订单信息存在Odders标里面而这个地址快照被我们存到了OddersGum而Jets这么另外一个标里面看看在Java代码里我们如何通过接口和实现来优雅的处理它第一步要定一个清晰的接口在DDD中称为防辅层在核心业务代码之中只应该看到这些干净的接口像这样订单对象就只管从业务场景出发要用那些属性那些与数据库存储打交道的脏乱岔的代码交给仓库接口和工厂接口第二步编写脏乱岔的实现类所有与数据库打交道的复杂逻辑都单独封装到这些接口后面的实现类里面还是仓库只负责管理对象如果有缓存逻辑那就交给仓库管理像这样至于最终对象不管来自于多少张表通通交给工厂就可以了像这样接下来结合Spring带来的模拟看到了没业务代码只需要和order repository接口打交道现在如果我们要从Messico换成Mongodb只需要再写一套order repository mongolampere和order factory mongolampere如果你用的是Spring框架切换就变得极其简单你甚至可以让两个实现类并存比如在Messico的实现类上加上一个注解Add Qualify Messico在Mongod实现类上加上一个Add Qualify mongol你的业务代码想用哪个只需要注入的时候指定一下就行了甚至可以把其中一个标记为Add Primary作为默认选项那么切换数据员对上层业务代码来说真的就是调整一个注解的事情核心代码文思不动好了现在让我们回到最初的问题说任何存储结构都可以我到底是不是在获悉你滴滴滴给出了答案是不要纠结于在项目第一天就选出完美的存储方案而是要构建一个能够拥抱变化的架构这里有一个很深刻的哲学滴滴滴它并不保证你一开始就能够做出最流的设计但它能保证当你说的业务的深入变得越来越聪明的时候不会被自己当初的愚蠢附设附较我们刚刚就是一个项目时对业务的理解必然是浮浅的我们做的设计是我们当时认知水平下的最优结一年后我们成了业务专家回头看可能会觉得当初的设计太蠢了如果代码是撼死的那这个愚蠢的设计就会成为你的历史保护让你寸步难行但如果你用了滴滴滴的格理思想把它变得更聪明时你可以随时重构你的工厂实现优化你的表结构甚至更换你的数据库你的核心业务逻辑因为被保护得很好所以你可以大胆的去迭代让系统跟随你的认知一起成长这才是任何存储结构都可以的真正底气所在你的选择只是一个可以随时更换的实现细节而不是一个会把你锁死的历史保护如果这期视频能够解决你的一些困惑请点个关注加点赞滴滴滴给了业界一个不一样的思考而我将给你带来一个不一样的滴滴滴关于滴滴滴你还有哪些困惑或者你在时间中踩过那些坑欢迎在评论区留言我们一起交流一起进步感谢大家咱们下期再见