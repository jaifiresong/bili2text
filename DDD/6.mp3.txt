最近我经常帮一些粉丝朋友看简历 发现一个特别普遍的问题大家在简历上都会写精通微服 熟悉高并发但一到模拟面试的环节 我喜欢问一个最经典的问题如果现在给你一个百万并发的业务场景 你的微服系统从头到尾应该怎么去设计这时候90%的反应是什么呢我可以用Redis加缓存 我可以用MQ做一步节奥 我也可以用SpringCloud加机器这你说一点 那你说一点 整个就跟爆菜名式的一个一个技术往外蹦 听到我的头一脑脏我试着提醒他们 用Redis就行了吗 或者不用Redis就做不了缓存加速了吗能不能成体系一点 很多人的反应往往就是不止所措了你要知道如果一个面试官真的问你这个问题 考的绝对不是你值不值得某一个工具而是看你有没有成体系的架构思维看你能不能从并发这个问题出发 把微服整个链路给梳理清楚做到这一点 就算有一些具体技术你记得可能不是很熟练了面试官也会相信你是能够解决问题的 因为学技术其实很快的但是如果你做不到这一点 你会再多的技术 面试官也永远只会考虑性价比在AI时代 这基本上就又意味着这场面试崩了说这么多什么意思呢 那么今天这期视频我就把这个庞大的高兵发问题拆解成三个核心招式在讲具体的工具之前 我会先带你搞懂为什么要这么设计也就是背后的设计哲学 听完这期视频 下次面试再遇到这一类问题按这个思路来组织 先给面试官讲出一套逻辑避还 再加上一些你自己的技术细节 保证打完你自己都会觉得很爽觉得这种受人以余的方式有帮助的 先把赞点上 我们马上开始好 面对百万病发 第一招呢 永远是拆 核心思想是什么 就是分而置之单体架构就像一辆马车 马再强壮跑得也慢 威服就是动车组 每节车厢都有动力 还能根据情况自行组装那具体怎么拆呢 通常来说第一步是服务的拆分有致力 我们可以把庞大的单体架构按照业务领域拆分成用户订单支付库存这些独立的服务 但拆完了之后服务A怎么找到服务B的几百个服务实力ip变了变去怎么办呢 这时候我们需要一个通讯路 也就是注册中心 至于落地工具现在手推的是necose 怎么工作的呢 也告诉面试官 服务启动时后段服务自动把自己的ip端口注册到necose调用方通过necose获取健康实力列表 再配合reben或者是load balancer做附带均衡这里有个假分项提到necose的动态配置管理 百万兵发下 我需要动态调整现成时 残酥或者日治级别不用重启服务necose配置一改 权量下发 这才是云元生时代的玩法第二步 数据拆分 服务拆了 数据库如果还是用了同一个 那数据库就是那个最容易被laced的马了所以垂直分库是必须的 做到专库专用 这样可以解决服务太多 数据库连接数太多的问题 减少数据库的压力但如果订单表一年产生一条数据怎么办呢 如果数据量真的太大了 就不要再纠结那些小打小闹的舍口优化了这时候就必须上水平分表 落地工具呢 现在首选是推荐sharding sphere再加上一些自己的实现细节 比如我们利用sharding及dbc配置好分片件 再通过一致性哈希算法 把一张大表拆成1024张小表均匀分布在不同的物理磁盘上 这样就把集中的l压力打败了那说到分库分表这里还一个巨大的坑 就是分布式失误原来在单体架构下一个transaction的注解就管用了那现在怎么保证分布式常理上数据一致性呢 知道答案的朋友可以在评论区说说你的看法 我看看有多少人踩过这样的坑也不给大家卖关子 如果你是真的熟悉这个sharding sphere 那么这个问题马上就有了一个标准的答案对 可以使用数据库的XA协议或者引入C塔 用AT模式或者TCC模式来解决跨库的事物问题把这事一提又是一个妥妥的加分项那拆分只是解决了扩展性的问题 但如果流量瞬间爆发 比如双十一零点 数据库还是容易会被打挂这时候我们就需要第二招缓冲 核心思想是什么呢 以柔克纲 具体来说就是挡和消这些洪水来了 我们不能把水直接冲进村庄得先修一个水库 把水留住 这就是MQ的作用 还得在村口对一些沙袋来做一些缓存第一层可以做一些缓存的前置 就是Redis 这一层的核心目标就是过滤无效请求读取热点数据请求进来之后先别去查库 先查Redis 比如说秒杀场景 库村没了 直接的Redis已经收倾 数据库根本感觉不到压力这里有经验的面试官可能会追问Redis挂了怎么办 或者查不到了怎么办 这时候你要主动抛出这三个概念显得你的体系很丰满一个是缓存穿透 查一个根本不存在的数据导致请求直接透到了数据库里面解决方案通常是用布伦过滤器或者是把空结果也缓存起来第二个缓存机穿 一个热点key突然过期大量请求瞬间机穿 解决方案可以设置一个逻辑过期或者加一些护次数还有第三个的缓存雪崩大量key同时过期 解决方案可以给过期时间加一个随机值 别让他们臭热闹一起死有了第一层缓存 接下来还有第二层缓存一步消风有效请求通过Redis 如果是写操作 比如下单阵的操作 千万别同步写库 这是我们可以引入mq消息队列它的核心逻辑就是用户下单之后 我发个消息给mq 立马给用户返回排队中这是耗时只要10毫秒 然后后台的订单户根据自己的能力慢悠悠的从mq里面拉取消息进行处理这就把瞬间的高并发变成了平稳的低并发落地选行通常来说比较建议卡福卡或者是rocket mq 但卡福卡呢它更加适合像日制买点这些吞吐量变太高的场景更多场景呢我们会习惯用rocket mq 它比较适合金融交易而且它支持失误消息可靠性非常的好这一块也有个坑 mq消息发重复了怎么办一定要在消费端做密等性设计比如用reddit记录消息id记录过的绝不处理第二次这一块呢又是一个妥妥的加分项如果听懂的朋友可以在评论区打个666咱们继续下一招好前面两招呢是进攻那么第三招就是防守万一流量真的超过了系统的物理极限或者某个服务代码写的烂包错了怎么办我们就需要建立一套多维的防御体系核心思路就是层层设防丢居保率第一层防线呢网关层这是系统的大门我们在这里可以做一些ip 维度的限流比如用andicus的限流某块限制同一个ip 每秒只能访问五次这就能把大部分恶意的爬虫脚本攻击直接挡在门外根本不让他们消耗后盾的资源第二层防线应用层这就是系统的内功了流量进了wave内部那现在推荐可以使用阿里的santinel他比以前的hattrix更强大可以支持控制台的可视化配置我们在这里主要做三件事情第一件是限流qps超过1000直接拒绝保护服务不被压垮第二个熔断下游支付服务挂了上游订单服务千万别死等直接熔断防止血绷降级大触高峰期把查看历史订单商品推荐这些非核心业务直接降级返回空数据把cpu和内存全让给下单和支付这些核心业务如果你是海外项目或者追求存代码控制也可以用re silence 4j但无论是什么核心都是要构建网关防外敌应用防内乱的整个立体防御网络好了到这里我们来复盘一下当面是个问题百万并发生你的脑海里应该立马浮现出整个这一张图第一个拆分层用nacos和shuttle sphere解决系统的扩展性平仅第二个缓冲层用radis抗毒压力用rocket mq抗血压力第三个防御层用index和santinel国建多维防御网解决稳定性的问题朋友们技术在变工具也在变但架构的设计思路是不会变的面试的时候千万别再像背书一样去背各种配置你要像讲故事一样讲思路讲痛点将解决方案这才是ai时代能够拿30k50k offer的关键如果你觉得这期视频帮你梳理清楚了思路一定要点赞收藏转发我是罗兰关注我it路上一起进步我们下期再见